C程序从高级语言到可执行文件的过程包括：预处理、编译、汇编和链接。
# 预编译
``` Shell session
	gcc -E hello.c -o hello.i
```

处理所有的#开头的语句，并生成一个.ii或.i文件
- 删除所有的注释
- 删除#define并展开宏定义
- 处理条件预编译指令
- 保留#pragma编译器指令
- 添加行号和文件标识
- 处理#include预编译指令，把被包含的文件插入到指定位置
# 编译
把预处理后的文件生成相遇的汇编代码文件
``` Shell session
	gcc -S hello.i -o hello.s
```
## 扫描
进行词法分析，运用有限状态机算法，将源代码分割成一系列记号，将产生的记号分为关键字、标识符、字面量等，将标识符放到符号表，将厂里存放在文字表等等。
## 语法分析
由上述的记号生成一个语法树，以表达式为节点
## 语义分析
判断语义是否有意义，比如两个指针之间的运算是不允许的。
编译器可以分析静态语义，而动态语义是在运行时才能确定，比如除以一个0就是运行时报错。
这个阶段还会进行声明和类型的匹配，类型的转换。
## 源代码优化
将语法树转换成为中间代码，并且进行优化，这时的代码非常接近目标代码了，只是这一步的代码是用类似于C语言的形式生成的颗粒度很小的代码。
==到这里为止，都是编译器前端的工作，前端的工作目标是生成与机器无关的中间代码。
接下来是编译器后端的工作，这部分是将中间代码转换成目标机器代码。==
## 代码生成
将中间代码根据机器的字长、寄存器、整数数据类型和浮点数数据类型等翻译成汇编代码。
## 目标代码优化
将上面得到的汇编代码进行优化，例如选择合适的寻址方式、使用位移代替乘法运算等。
# 汇编
将汇编代码转变为机器可以执行的指令，只需要根据汇编指令和机器指令对照表一一翻译即可。这时得到的就是目标文件。
``` shell
gcc -c hello.s -o hello.o
```
# 链接
由于代码中将不同的功能封装成一个个小模块，因此当一个模块中的程序调用了另一个模块中的功能时，就需要将这两个模块链接起来才能执行。
这种链接有两种方式，一种是模块间的函数调用，一种是模块间的变量访问。最终都可以归结为模块间符号的引用。
## 静态链接
当在一个程序中调用了另一个模块中的函数foo()，但是这个程序并不知道foo的地址，那么它就把这个地址暂时搁置，等到链接的时候再填上这个地址。


















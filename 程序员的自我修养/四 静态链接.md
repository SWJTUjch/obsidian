# 空间与地址分配
- 地址和空间有两层含义
	- 可执行文件中的空间
	- 虚拟地址的空间（一般更关注这个地址）
- 两步链接
	- 空间与地址分配：扫描目标文件并获得各个段的地址、长度和属性，手机符号并放入一个全局符号表，计算出各个段合并后的长度和位置，建立映射关系。其中一些辅助功能的段的大小并不是简单相加，而是进行合并之后的结果，rela段被消除。
	- 符号解析与重定位：读取文件中段的数据、重定位信息，解析符号、重定位、调整代码中的地址
![a.o](a_header.png)
![b.o](b_header.png)
![ab](ab_header.png)
# 确定符号地址
- 符号包括变量符号和函数符号
- 扫描之后，各个段的虚拟地址就确定了
- .text段的顺序按照ld命令中的顺序排布，虚拟地址就是0x004000e8，a.c中的main函数的偏移是0，那么其地址就是0x004000e8。b.c中swap函数相对于其text段的偏移是0，那么就在main函数之后的地址。
# 重定位
在a.o文件中，shared和swap都属于未决议状态，因此调用shared的时候，就在rip上加了0，调用swap函数时，也是调用了下一条语句，实际上是没有执行任何操作。
![](a_disassembly.png)
但是在链接之后的代码中，rsi和调用swap函数的汇编代码都被赋予了正确的值。swap函数代码段在main后面，就是400116，而shared变量的地址是600164
![](ab_disassembly.png)
但是，链接器又是怎样知道每个变量/函数是未决议的呢？也就是说生成的代码中哪些地方需要进行重定位呢？
## 重定位表
- 重定位表在elf文件中是一个单独的段，以rela.开头，后面跟随的表示是这个段的重定位表。比如text段需要被重定位，那么就会有一个.rela.text作为text段的重定位表。
![](a_rela.png)




















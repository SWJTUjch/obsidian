目标文件的后缀在linux中是.o，在windows中是.obj，是汇编之后生成的二进制文件，但是还没有经过链接。[[二 编译和链接]]
# 怎样得到一个目标文件
```shell
gcc -c SimpleSection.c
objdump -h SimpleSection.o
readelf -h SimpleSection.o
```

elf文件整体结构如图所示：
![](elf.png)
# ELF文件结构
## ELF文件头
![](header.png)

==魔数==
- 前4个字节固定是7f 45 4c 46，即对应ELF的ASCII码。
- 第5个字节是表示ELF文件类，0x01表示32位，0x02表示64位
- 第6个字节表示字节序，0x01表示小端，0x02表示大端
- 第7个字节表示版本号，通常为1
- 后面9个字节都为0，扩展用
==文件类型==
- RT_REL：可重定位文件.o
- RT_EXEC：可执行文件
- RT_DYN：共享目标文件.so
==入口地址==
ELF程序的入口虚拟地址，默认是_start函数，也可以通过ld脚本中的ENTRY()语句控制选择入口函数，从而更改入口地址。比如pulsar项目上定义了新的入口函数
==段表在文件中的偏移==
指示段表从哪里开始，段表中存储了程序分段的详细信息（这个程序中是0x450）
## .text段
存储的是编译后执行语句的机器代码，是只读的。将代码段和数据段分开存放，有三方面好处：
- 可以避免代码被程序改写
- 提高缓存命中率
- 对于只读的部分来说，可以共享
## .data段
保存的是已经被初始化的全局静态变量和局部静态变量
## .bss段
- 存放的是**未初始化**的全局变量和局部静态变量，但实际上只是预留位置，而实际上这一段内存中没有存放任何内容。在后面装载的时候会在虚拟内存中分配内存。
- 有些编译器为了优化，会把初始化为0的数据也存放在.bss段里
## .rodata段
- 存放的是const常量和字符串常量，可以避免被修改。在这个例子中，printf函数中的字符串就被放在这里了。
- 有些嵌入式系统中，会把这段数据放到ROM中，这样就加了一层硬件保护
![](pwm_normal_boot_ro.png)
![](pwm_normal_boot_bss.png)
而实际的硬件内存地址映射为：
![](memory_region.png)
所以rodata部分的数据实际上存储在FLASH中，但是这也产生了一些问题，比如：
```C
struct str{
	int a;
	const int b;
	const* int c;
	int* const d;
}
```
这样的结构体会被存放在rodata中，但是其中的a和c是可以被更改的，而在上面的嵌入式系统中，这两个non-const的数据也无法被更改。
## section table
段表中存储了文件的段结构。包括每个段的名称、大小、偏移地址、段地址对齐等。
## .rel.xxx段, 重定位表
用于在链接时对目标文件中的某些部位进行重定位。
比如：.rel.text就是对.text段中的重定位，因为.text中包含了printf函数，这个函数需要进行链接，也就是对一个绝对地址的引用。
## 字符串表.shstrtab和.strtab
ELF文件中把所有的字符串集中在一起，存放在一个表中，使用字符串在表中的偏移来引用字符串。
其中.shstrtab是用于存放段表中用到的字符串，比如段名
![](shstrtab.png)
.strtab用于存放普通的字符串，比如符号名字
![](strtab.png)
## symbol table 符号表
- 符号表里面的符号就是目标文件中用到的所有的变量和符号
![](symbol.png)
- 其中的value值存放的就是在这个段（Ndx标识）中的偏移值。
- Ndx为符号所在段
	- ABS：符号包含了一个绝对值，比如文件名
	- COM：COMMON Block，未初始化的全局符号定义
	- UND：定义在其他函数中，这些变量在当前不占用空间进行存储，指示在符号表中有这样一项










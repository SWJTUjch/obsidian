# 项目预备知识
## fastDFS
### 三个组成部分
- storage：是存储文件的载体，storage会启动一个单独的线程来完成对一台tracker的连接和定时报告，主动向tracker报告其状态信息，包括：
	- 磁盘剩余空间
	- 文件同步状况
	- 文件上传下载次数
- tracker：会根据storage汇报的信息决定要将文件存储到哪个节点上，
- 客户端：在我们这个项目中就是web服务器的fastcgi里面创建的一个进程，客户端向服务器传输文件，并得到文件的ID

### 存储文件的流程
- 客户端向tracker发送一个上传文件的请求，然后tracker会查询哪一个节点有足够的空间存储这个文件，并且通过一定的负载均衡算法得到存储节点，就发送这个节点的IP和端口，客户端通过获取的信息连接到存储节点，再去上传文件，并且得到一个文件ID
- 当需要下载一个文件的时候就发送一个下载文件的请求，tracker会查询自己的表告诉客户端文件存储在哪个节点上，客户端再访问节点提供组名路径文件名进行读取数据的操作。


### tracker配置文件的修改
- 位置：/etc/fdfs
- bind_addr：主机IP
- port：绑定的端口
- base_path：log目录（绝对路径）

### storage配置文件的修改
- group_name：存储节点所属的组（属于哪个集群，同一组是备份，不同组是扩容）
- bind_addr：
- port
- base_path
- storage_path_count：存储路径的数目可以指定多个
- store_path0：上面指定了多少个就要在这里设置多少个路径，从0开始编号
- tracker_server：IP:port  连接的tracker的IP和端口

### client配置文件的修改
- base_path
- tracker_server

### 常用操作
- 启动tracker：fdfs_tracker /etc/fdfs/tracker.conf (restart/stop)
- 启动storage：fdfs_tracker /etc/fdfs/storage.conf (restart/stop)
- 监测配置：fdfs_monitor /etc/fdfs/client.conf
- 上传文件操作：fdfs_upload_file /etc/fdfs/client.conf xxx
	- 会得到一个文件的id：group1/M00/00/00/xxxxxx
	- group1-组名
	- M00-虚拟磁盘路径：对应storage.conf中的store_path*
	- 00/00-二级目录，存储上传文件的目录
- 下载文件操作：fdfs_download_file group1/......

### 实际的上传下载流程
- 上传操作先从客户端上传到服务器，再由服务器端的client上传到存储节点，这个过程是因为服务器需要将文件分享给别人，所以需要再服务器端存储一个文件的url
	- 如果使用api进行上传，需要先在客户端安装fastdfs的client，然后向服务器请求文件存储的ip和端口，然后开一个进程上传文件，再把文件id发送到服务器上
- 下载操作就是客户端从服务器请求url，然后客户端直接通过这个url请求存储节点就可以下载了

### 找不到动态库怎么解决
- ldd a.out
- find /usr/local/lib -name "libfcgi.so"
- vim /etc/ld.so.conf
	- /usr/local/lib
- sudo ldconfig


## Nginx
### 什么是Nginx？
Nginx是一个轻量级高性能的反向代理web服务器，用于http、https、smtp等协议，可以处理2-3万并发连接数。

### Nginx的优点
- 跨平台，配置简单
- 非阻塞，高并发连接
- 内存消耗小
- 成本低且开源
- 稳定性高
- 可以热重启

### nginx的用处：
- http服务器，处理http协议
- 反向代理服务器
- 邮件服务器：IMAP/POP2/SMTP

### 正向代理和反向代理的区别
浏览器无法访问到外部的浏览器，需要通过代理服务器作为中继来访问
反向代理是指当访问量过大时，该服务器可以实现web服务器的负载均衡，让大量的访问相对平均地落到每一个web服务器上。

### 什么是负载均衡
增加服务器的数量，构建集群，将请求分发到各个服务器上，将原来请求集中到单个服务器的情况改为请求分发到多个服务器

### 常用的负载均衡类型
- DNS服务器：在DNS服务器处配置多个网站的记录，DNS循环给用户分配实际的地址
	- 优点：
		- 使用简单，避免了维护负载均衡服务器的麻烦
		- 可以支持基于地址的域名解析，解析成距离用户最近的服务器地址，可以加快访问速度，改善性能。
	- 缺点：
		- 可用性差：DNS解析是多级解析，新增/修改DNS后，解析时间较长，解析过程中，用户访问网站将失败
		- 扩展性差：控制权在域名商那里，无法更改权重
		- 维护性差：不能反映服务器当前运行状态
- IP负载均衡：在内核的网络层修改目标地址为集群中的一个，集群中的服务器将响应返回给负载均衡服务器，再有负载均衡服务器返回给用户
	- 优点：在内核分发数据比在应用层分发要好
	- 缺点：所有请求响应都需要经过负载均衡服务器，集群最大吞吐量受限于负载均衡服务器网卡带宽；
- 链路层负载均衡：负载均衡时不修改IP地址，只修改目标的mac地址，配置真实物理服务器集群所有机器虚拟ip和负载均衡服务器IP地址一致。但是在返回时，由于mac地址不一致，所以在网络层使用这个IP并且使用服务器自己的MAC地址，用户也能收到，而不需要再走负载均衡服务器了
	- 优点：性能好
	- 缺点：配置复杂

### 负载均衡算法
- 轮询：不适合集群中服务器硬件不同的场景
- 随机：同上
- 最少链接：将请求分配到连接数最少的服务器，可以动态分配，但是需要监控服务器请求连接数
- IP Hash：使来自同一个IP的访客固定访问一台后端服务器，目标服务器宕机后会话会丢失
- 加权：

### 动静分离
为了加快网站的解析速度，可以把动态资源和静态资源分离，可以根据静态资源的特点做缓存操作。

### 为什么要做动静分离？
有些请求需要后台处理，即动态文件，有些不需要经过后台处理，称为静态文件，动静分离之后可以提供用户访问静态代码的素组，降低对后台应用的访问。

### 怎样做到动静分离？
需要指定路径对应的目录，在location块中使用正则表达式进行匹配，并指定对应的磁盘中的目录



### 配置文件
配置文件位于/usr/local/nginx/conf/nginx.conf
- 全局main块：设置Nginx服务器整体运行性能的配置
	- worker_process auto：设置nginx进程数，一般设置为和CPU核数一样
	- error_log：错误日志的存放路径，是/usr/local/nginx的相对路径
	- pid：存放nginx进程的pid
	- 
- events块：设置网络连接配置，比如是否开启对多 workprocess 下的网络连接进行序列化，是否允许同时接收多个网络连接等等。
	- use epoll;	//使用epoll的IO模型
    - worker_connections  1024;		//每个进程最大允许1024个并发
- http块：部署静态网页、反向代理、负载均衡
	- 部署静态网页
	```
	loaction / {		//url
		root	demo;	//对应网页相对于根目录的位置
		index	first.html;		//具体的需要加载的网页
	}
	loaction /second.html {		//url
		root	demo;	//对应网页相对于根目录的位置
		index	second.html;		//具体的需要加载的网页
	}
	loaction /hello/index.html {		//url
		root	demo;	//对应网页相对于根目录的位置
		index	index.html;		//具体的需要加载的网页，应该位于/demo/hello/index.html
	}
	loaction /hello/ {		//如果hello是一个目录，后面必须加/
		root	demo;	//对应网页相对于根目录的位置
		index	index.html;		//具体的需要加载的网页，应该位于/demo/hello/index.html
	}
	```
	- 反向代理
	```
	server{
		listen	80;		//监听80端口
		servername	192.168.3.114;
		location /tag(url){
			proxy_pass	http://192.18.3.116:8080;
		}
	}
	upstream 1.test{
		server 	192.168.3.116:80;
	}
	server{
		listen	80;		//监听80端口
		servername	1.com;
		location /tag(url){
			proxy_pass	http://1.test;
		}
	}
	```
	- 负载均衡
	```
	upstream 1.test{
		server 	192.168.3.116:80	weight=1;
		server	192.168.3.117:80	weight=1;
	}
	server{
		listen	80;		//监听80端口
		servername	1.com;
		location /tag(url){
			proxy_pass	http://1.test;
		}
	}
	```


### Nginx常用命令
> sudo nginx           //启动nginx
> nginx -s reload      //重新加载配置文件
> nginx -s reopen      //重启
> nginx -s stop        //快速关闭
> nginx -s quit        //当前任务完成后关闭
> systemctl enable nginx    //开机启动
> systemctl disable    //关闭开机自启动


### http块常用配置解析
- log_format：日志模式
- access_log：访问日志存放位置
- sendfile：开启高效传输模式
- include：文件扩展名与类型映射表
- default-type：默认文件类型
- server段：
	- listen：监听的端口
	- server_name：配置的域名
- loaction段：
	- root：网站根目录
	- index：默认首页文件
	- deny：禁止访问的IP地址

### Nginx是怎么处理请求的？
- 首先，在启动时会解析配置文件，得到需要监听的端口与IP地址，然后在master进程里面初始化这个用于监听的socket
- 接下来会fork多个子进程
- 这些子进程会竞争accept新的连接，但是只有其中一个可以获得这个连接，然后创建nginx对这个连接的封装
- 接下来设置读写事件处理函数，并且添加读写事件来与客户端进行数据交换
- 关闭连接

### nginx如何实现高并发的？
采用异步非阻塞的工作方式。每来一个新的request，就有一个进程来处理这个request，如果发生阻塞，就注册一个回调函数事件，然后去处理别的请求，直到等待的事件已经完成并触发了这个回调函数，该进程才会继续处理。

### 为什么nginx不使用多线程
nginx使用异步非阻塞处理主线程上的连接请求，不会为每个请求分配CPU和内存资源，减少了大量的CPU上下文切换

### 


## fastCGI
### 为什么要使用fastCGI
因为nginx只能部署静态网页，无法部署动态网页，因此对于登录操作，上传下载查询等操作无法直接处理。

### CGI的工作流程
- 用户先发送一个请求，请求nginx的web服务器
- web服务器fork一个CGI子进程，把要处理的数据传递给CGI程序
- CGI程序解析数据库并且执行相应操作
- CGI把返回的结果发送给web服务器，服务器再把响应发送给用户
- fastCGI会为每一个工作创建一个进程

### spawn-fcgi中间件
- 由于nginx不能直接处理CGI请求，所以需要spawn-fcgi作为nginx和fastCGI之间的桥梁
- nginx把数据通过某一端口发送给spawn-fcgi
- spawn-fcgi监听这个端口，然后通过管道转发给对应的fastCGI
- fastCGI再执行对应的任务
- 由于在创建管道时对于端口都重定向了，所以fastCGI可以从标准输入得到数据，printf时就可以把数据返回到spawn-fcgi。

### 在nginx中配置fastCGI
````
location /test{
	fastcgi_pass 127.0.0.1:9001;
	include fastcgi.conf
}
````

### spawn-fcgi的使用
`spawn-fcgi -a IP -p port -f fastcgi_program`
- -a：nginx服务器的IP
- -p：监听的端口（服务器把数据发送到这个端口
- -f：fastcgi程序，spawn-fcgi启动的可执行程序




# 项目经历
## 网盘
### 概述
- 项目描述
基于nginx+fastCGI+fastDFS构建的分布式存储服务，编写了客户端业务代码，并使用QT构建了客户端程序。可以实现文件的上传、下载、删除、分享等功能。
- 主要工作：
	- 搭建nginx+fastCGI+fastDFS环境，配置nginx的反向代理和负载均衡功能
	- 使用MySQL存储用户文件，使用redis缓存用户登录信息
	- 通过记录文件的md5值进行标记，若上传相同文件，可以实现秒传，同时通过引用计数实现文件共享
	- 通过存储文件url，可以由客户端直接请求fastDFS存储节点下载文件，避免了Nginx带宽的瓶颈
	- 客户端使用线程池实现多线程上传/下载任务
- 项目难点：
	- 线程池的创建
	- 搭建环境
	- QT的界面设计
- 遇到的bug及其解决方案：
	- 创建线程池总是编译出错，后来检查是因为没有把执行线程处理的函数声明为static成员函数，导致隐式地传递进了一个this指针，所以应该将其声明为static类型，并且显式地传递this指针。
	- 客户端界面拖动窗口出错，因为没有再点击窗口时计算窗口当前位置，需要在移动过程中减去这样的一个相对位置才能正确移动
- 项目日志怎么打印的：

### 整体介绍
整个项目是一个基于nginx+fastCGI+fastDFS构建的分布式存储服务，其中nginx作为反向代理服务器和负载均衡服务器，将Qt客户端发送过来的请求转发给后台的FastCGI进行动态请求的处理，fastCGI就解析客户端发来的http请求，并且调用fastDFS的API进行操作，fastDFS就是一个分布式存储架构。
并且还有一个MySQL数据库和Redis数据库，其中MySQL中存放用户信息、文件信息、用户文件、用户文件数量和共享文件列表，Redis中存放用户及其验证token，还有一个有序列表（用md5+文件名作为key）用于有序存放共享文件的下载量，减少查询MySQL，有一个哈希表存放文件id和文件名。
客户端的功能包括注册、登录、上传、下载、分享、删除、转存等文件功能，可以显示用户文件、共享文件、上传/下载文件进度等信息。客户端和服务器之间通过Json传递协议。

### 功能列表
- 获取文件列表
	- 升/降序
	- 刷新
	- 上传
	- 下载
	- 分享
	- 删除
	- 文件属性
- 共享列表
- 下载榜
- 传输列表
	- 上传
	- 下载
	- 传输记录
		- 传输记录
- 切换用户

### MySQL表设计
- 用户信息表（user_info）：存储用户信息，包括作为主键的自增ID，用户名等一切注册用的信息，注册时间。
- 文件信息表（file_info）：存储文件信息，包括作为主键的自增ID，文件md5、文件ID、url、大小、类型、引用计数等。
- 用户文件列表（user_file_list）：每行代表一个文件，并且指出文件所属用户、文件名字、共享状态、文件下载量等信息。因为涉及到文件共享和转存等功能，所以为了效率，两个表不能合并到一起，因为这个表无法记录文件的引用计数。
- 用户文件数量表（user_file_count）：存储每个用户的文件数量，有一个特殊用户，即后台记录共享文件的用户。
- 共享文件列表（share_file_list）：包括所属用户、md5、文件下载量、文件名字等信息。

### redis表设计
- 下载量表：用一个zset即有序集合来存储，因为有序，所以可以在下载榜中请求获取这个文件id，即md5值和文件名的组合，因为文件名可能会重复，所以需要使用md5值保证唯一性。
- 文件标识和文件名、用户对应表：可以通过文件id得到对应的文件名和用户。



### 客户端业务逻辑实现
（1）信号和槽的设计
使用QSignalMapper作为是信号的转发器， 它可以把一个信号翻译成QString参数的信号， 并将之转发。
先建立一个控件和QString对象的mapping映射，当控件发送了一个map()，就会发送一个对应的mapped(QString）信号。然后注册一个控件和槽的连接，一旦控件发送了一个信号，就相当于控件发送了一个map。
- 首先把原始的信号连接到QSignalMapper类的map()槽函数，这样QSignalMapper能在第一时间接收到原始信号
- 其次调用setMapping方法建立映射关系，告诉QSignalMapper对象怎样去处理原始信号。(映射关系通过对应一个整数、字符串或者QWidget* 实现)
- 最后通过接收QSignalMapper类转化后的带参信号mapped() 与槽函数连接，在槽函数中获得需要的数据，并作出对应的处理

（2）设置连接的服务器IP和端口信息
```
QRegExp regexp(IP_REG);		//初始化正则表达式类，IP_REG是规则
regexp.exactMatch(ip)			//检查是否匹配
regexp.setPattern(PORT_REG);	//改变正则表达式规则
(QByteArray)file.readAll()		//读取数据
QJsonDocument::fromJson(json, &error);	//根据json创建一个文件
doc.isObject()  doc.isNull()  doc.isEmpty()	//判断对象是否为空，文件是否为空
(QjsonObject) doc.object()		//获取这个对象
obj.value( title ).toObject()		//取出title对应的值，并转为对象
web_server.insert("ip", ip)		//插入键值对
QJsonDocument::fromVariant(json)	//转为json文档格式
```
- 读取用户输入的IP和端口数据，然后用正则表达式判断，如果正确，就跳转回登陆界面并且将配置信息写到配置文件中。
- 写配置文件：不能只修改配置文件中的部分信息，只能全都读进来之后再写回去，而且必须要拆解开之后再以map的形式存储组合
- 重点是读取login信息：首先用readAll读取所有内容并存储为字节数组，然后获取整个文件对应的对象，再根据对象来查找对应的值。
- QMap的insert插入键值对，最终还要把所有的键值对都综合起来，把这个键值对组合通过fromVariant转为json文件，注意这个函数只能转换map、list和stringlist，所以不能在前面把整个的key全都作为一个object来暂存，否则这里就没办法转换了。

（3）用户注册
```
(QnetworkRequest) request.setUrl(QUrl(url));
request.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("application/json"));
QNetworkReply* reply = m_manager->post(request, array);
```
- 首先从控件中获取用户的注册信息，然后将其打包为Json格式，发送的时候是用字节队列存储的。
- 需要设置url、设置头中的长度和类型，接下来使用post组合请求头和数据信息再发送数据，然后connect等待返回数据。
- 接收到数据后，从reply中读取全部数据，然后从这个json解析出返回数据，根据返回值得知是否正确
> 成功:         {"code":"002"}
> 该用户已存在：  {"code":"003"}
> 失败:         {"code":"004"}

（4）用户登录操作
用户读取或者填入用户名和密码，再通过设置的IP和端口可以连接到服务器，服务器反馈验证信息，如果正确，则用户登录成功，通过一个单例类管理用户登录信息，还要创建一个线程池，用于将来上传或下载操作。

（5）上传操作
- 我们有一个上传列表和下载列表，分别由两个链表QList维护，还有一个线程池中的任务列表，用于维护所有的上传下载任务。
- 在文件预览列表中构建右键菜单，里面包含有上传操作，点击之后，就开始上传操作，首先发送一个信号，切换到上传文件的界面，然后获得一个上传列表的实例，打开窗口选择文件，遍历文件并读取信息，包括判断文件大小、获取md5值等等，然后把这个实例添加到上传列表和任务列表中。线程池中的线程就会对任务列表中的文件进行上传操作。对上传列表和下载列表还应该分别维护一个互斥量，线程池中的线程会从任务列表中取走第一个任务，这个过程也是需要加锁的，一旦这个任务完成了，就会在对应的上传或下载列表中移除这个任务。上传下载列表主要是用于显示所有的任务。
- 执行上传操作时，需要先检查该文件在服务器上是否有个完全一样的，所以需要先post一个json数据，如果服务器返回表示已经有该文件了，那么就删除这个任务。如果服务器中没有这个文件，就需要上传了。上传过程就是把整个文件读出来，然后通过post发送出去，等待两个响应，一个是已经发送多少数据，一个是总共有多少数据，然后处理进度条。操作完成就删除，并且还要在布局中移除控件。
- 如果要取消所有的上传操作，首先要遍历整个线程池的任务列表，在任务列表中选择上传或下载任务进行删除，还要清空整个上传或下载列表。

（6）获取文件列表（正常顺序/升序/降序）
用户登录之后立即切换到当前用户的文件列表，首先清空列表，然后发送一个请求，获取用户的文件数量，并且把这个文件数量保存到类成员变量中，然后分批循环请求文件列表信息，把请求的位置和数量通过json发送到服务端，并将其保存到列表中，当文件数量小于0时，表示已经没有信息了，就清空所有已有的文件列表信息，把列表中的显示上去。升降序通过参数命令，在url中添加这个参数即可。

（7）下载操作
首先获得一个单例模式的下载列表实例，然后找到要下载文件的文件名，并选择要保存文件的地址，把任务添加到下载列表中，由于对每一个文件实例都存储了一个文件的下载地址，因此只需要post这个地址即可，发送一个信号表示开始下载，槽函数切换到传输界面的下载界面，然后把下载任务添加到任务队列中。其中下载操作会被封装成一个类，类中定义了一个process方法，用于执行下载任务，成员变量包括文件的名字、路径、url、用户名。下载时才创建文件描述符。

（8）分享/删除文件
把文件md5和文件名组成一个json包发送出去，并且通过url中的命令字段执行相应的操作。
对于删除操作，还应该把用户文件列表和界面上的文件删除

（9）文件属性
通过读取本地存储的文件信息，显示到对话框上

（10）共享列表
- 下载：和正常的文件下载操作一样，并且在下载之后还要发送pv信息，并且成功后同步更新到本地和服务器的pv值上
- 属性：同上
- 取消分享：同上，注意不是本用户分享的文件无法取消分享。
- 转存文件：如果是本用户的文件，无法转存
- 刷新：获取所有用户分享出来的文件，操作同前

（11）下载榜
同样是先查询有多少数据，然后再请求具体的数据


### 服务端业务逻辑实现
（1）注册`reg_cgi.c`
- 首先服务端调用FCGI_Accept等待用户连接，如果没有就阻塞，如果有就还会修改环境变量并重定向输入为CGI的输出，输出为CGI的输入，然后返回一个值。可以通过环境变量中的"CONTENT_LENGTH"字段查询收到的数据长度。把收到的数据存储到一个缓冲区中，来解析这个Json数据。
- 解析过程：首先把Json字符串转换成一个Json对象，然后依次返回不同键值对应的Json值。
- 得到用户名等信息之后，去数据库中查询，如果有数据就返回，没有数据就添加一个

（2）登录`login_cgi.c`
- 和注册时一样，先获取用户的用户名和密码，然后和数据库中进行比对，

（3）上传操作`upload_cgi.c`
- 首先从post报文中读取数据，包括文件信息和文件内容等。
- 为了保证数据的完整性，需要为报文设置分界线，这个分界线是一个随机字符串，
- 读取用户的信息，并且存储起来，然后读取文件，存储到本地。
- 接下来要把本地文件上传到分布式文件系统中，这个过程首先创建一个pipe，然后创建一个子进程，在子进程中把标准输出重定向到管道的输入端，这样可以把上传得到的返回值即文件ID传给父进程并返回。在子进程中通过execlp执行上传指令。
- 为了在下载时能让用户直接去请求对应的文件服务器，需要存储对应的文件服务器的地址，这时需要通过文件ID向文件系统查询文件的存储路径，和上述一样通过execlp执行通过pipe获得返回值，通过查询配置文件的搭配端口号，最后拼接成一个完整的url
- 还要删除本地缓存的文件，把文件的相关信息全部存储到mysql中，拼凑一个json返回值，然后就可以给客户端返回了

（4）查看文件`myfiles_cgi.c`
- 服务器先从url中解析出cmd后面的值，并且校验用户。如果是count就返回该用户有多少文件，如果是其他的就按照对应的值返回文件名。

（5）分享、删除文件`dealfile_cgi.c`
对于分享出来的文件由系统后台创建的一个用户管理
- 分享文件：
	- 先判断此文件是否已经分享，即判断redis的zset集合有没有这个文件，如果有，说明别人已经分享此文件，中断操作
	- 如果集合没有此元素，可能因为redis中没有记录，再从mysql中查询，如果mysql也没有，说明真没有(mysql操作)
	- 如果mysql有记录，而redis没有记录，说明redis没有保存此文件，redis保存此文件信息后，再中断操作(redis操作)
	- 如果此文件没有被分享，mysql保存一份持久化操作(mysql操作)。首先把共享状态设置为1，然后把文件相关信息保存在文件共享列表中，把文件数量更新到用户文件数量的列表中
	- redis集合中增加一个元素(redis操作)
	- redis对应的hash也需要变化 (redis操作)
- 删除文件
	- 先判断此文件是否已经分享
	- 判断集合有没有这个文件，如果有，说明别人已经分享此文件(redis操作)
	- 如果集合没有此元素，可能因为redis中没有记录，再从mysql中查询，如果mysql也没有，说明真没有(mysql操作)
	- 如果mysql有记录，而redis没有记录，那么分享文件处理只需要处理mysql (mysql操作)，在共享文件表中删除这个文件记录，在文件数表中减1
	- 如果redis有记录，mysql和redis都需要处理，删除相关记录，redis就删除有序集合和哈希集合中的数据
	- 接下来修改用户文件数量和用户文件列表
- 文件下载后更新pv信息
	- 先获取文件pv值，然后加1

(6)共享文件pv字段处理、取消分享、转存文件cgi程序`dealsharefile_cgi.c`
- pv字段处理：
从mySQL中获取文件的pv值，然后加1，并将这个值更新到表中，接下来判断是否在redis中，如果在redis中，就将其score+1，如果不在就从MySQL中取数据，更新Redis中的两个表
- 取消分享：首先处理用户文件列表并将其分享标志置为0，然后查询并更新共享文件数量，删除MySQL共享文件表中的对应项，接下来删除redis表中的对应项。
- 转存文件：首先查看用户是否已经有该文件，如果没有就查找并修改文件信息表中的count值，然后在用户文件列表中插入这一项记录，查询并更新用户文件数量

（7）秒传`md5_cgi.c`
如果没有该文件，就返回相应的json包，如果有，就查询并更新用户的文件数量，并且在用户文件列表中插入这条数据。

（8）共享文件相关操作`sharefiles_cgi.c`
- 获取共享文件数量
直接查询用户文件表中的后台用户的数量
- 获取共享文件列表
通过不断查询共享文件表并将其信息拼成json包发送到用户端
- 获取共享文件下载榜
只需要查询redis即可，如果redis中共享文件的数据和MySQL中不一样，就清空redis然后从MySQL更新过来，由于只需要文件名即可，所以使用redis更快一些，且redis的zset可以按照pv值降序排列。

### 为什么使用base64？
因为http协议中有很多不可见的字符，在传输过程中要经过多个路由设备，由于不同设备对于字符的处理方式可能不同，这些不可见的字符就可能会被错误处理，不利于传输。而且可以进行一定的加密

### base64算法描述
把3个8字节转换成4个6字节
在6位的前面补2个0，这样就变成了4个8字节
如果剩下的字符不足3个字节，就用0填充，输出字符使用"="，解码时会被自动去掉

### MySQL相关API
|API|功能|
|---|---|
|mysql_init|初始化|
|mysql_real_connect|尝试与运行在主机上的MySQL数据库引擎建立连接|
|mysql_close|关闭数据库|
|mysql_fetch_row|从得到的数据库结果结构中提取一行，并把它放到一个行结构中|
|mysql_num_fields|获取结果中列的个数|
|mysql_num_rows|获取结果中行的数量|
|mysql_query|使用命令查询|
|mysql_store_result|生成结果集|
|mysql_free_result|释放结果集结构指针|

## 基于5G和LTE-V2X技术的有轨电车无线通信系统
### 功能
首先，从宏观上来说，本项目是基于5G和LTE-V2X无线通信技术，为各类数据业务、子系统提供高速率、高可靠、高容错、低时延的数据通道，实现有轨电车的智能列控、合理调度、安全行车。首选通过5G技术实现车与调度中心之间的车地通信，即车辆向调度中心发送自己的位置和速度等信息， 控制中心向车辆发送行车区段的其他电车的车次号、轨旁信号灯变化等信息，辅助司机驾驶。当5G网络较差或彻底无法使用时，车车通信和车与轨旁设施通信就可以派上用场了，通过车辆与周围设施之间的信息交互，可以获得和来自控制中心同样的信息，为安全行驶加上了一道保险。当5G网络恢复正常时，仍然可以自动切换到5G网络上。
我们做的是基于华为5G工业模组MH5000-871开发的车载无线通信系统和轨旁设置的无线通信系统，我们开发了自动配置模块和数据转发模块。首先数据配置模块是开机自启动配置路由、DNS和DHCP等信息；数据转发模块则根据应用层的需求通过Uu接口或PC5接口收发数据。
考虑到不仅有列控列调的数据要去传输，还有PIS（乘客信息系统）环境与设备监控系统（BAS）等数据传输，而这些数据都是来自于不同的终端，因此我们使用了epoll
### 使用了什么网络协议？
有线传输使用的是UDP协议，不使用TCP的原因是由特定的场景决定的，列车传输的是列控信息，以及当前的位置速度等信息，只关心当前情况，而且发送频率很快，所以没有必要重传，历史数据对于列车没有意义，而且是在局域网内传输的，距离很短，丢包的可能性很小。由于在收到上层发送的UDP包之后会给上层一个反馈，因此如果发生了长时间连续的丢包，在应用层是可以通过设置超时然后执行相应的操作，比如向驾驶员警告通信中断等。
无线传输部分是V2X协议，V2X实际上是一个面向无连接的广播协议，由于MH5000是基于R14的协议，因此可靠性方面的表现还比较差。而且由于发送端并不知道有多少接收端收数据，因此通过当前的V2X难以实现可靠传输。在R15版的协议中，引入了点对点的V2X，包括可以通过RSU进行V2X的协同通信。

### 怎么判断数据包是不是自己所需要的？
通过数据包的优先级字段识别

### 数据到来时怎么处理？
分为两种数据，第一种是来自于本地的车辆或OLC的周期性数据，这是通过网线连接的，所以直接调用socket接收数据，然后判断该数据应该发往哪里，再通过V2X的发送数据函数将数据转发出去。
第二种是无线接收到的数据，是通过回调函数处理的，具体的底层实现没有开放，我猜想是PC5接口收到数据之后引起中断，然后调用中断处理函数，中断处理函数中再调用由我们实现并注册的回调函数。在回调函数中我们做的工作就是判断数据是否是发给自己的，如果不是，就直接丢弃。

### 用到了哪些函数
bzero函数，用于清空一些内存
htons/htonl函数：输入端口号或ip地址，将其转为网络字节序（大端）
inet_aton函数：用于将点分十进制数串转为32位的地址，第一个参数传入，第二个参数传出，返回成功或失败
socket函数：创建一个套接字文件，第一个参数设定协议族，第二个参数设置套接字类型（数据报套接字），第三个参数设置协议
bind函数：把一个本地协议地址赋予一个套接字，第一个参数是套接字文件描述符，第二个参数是协议地址的指针，第三个参数是整个地址结构体的长度。
recvfrom函数：第一个参数指示sockfd，第二个参数是缓存地址，第三个参数是缓冲区的可用大小，第五个参数是发送者的套接字地址，第六个参数是套接字结构体的长度
sendto函数：第一个参数指示sockfd，第二个参数是缓存地址，第三个参数是缓冲区的可用大小，第五个参数是接收端的套接字地址，第六个参数是套接字结构体的长度

### 如何实现5G到V2X的切换？
有一个进程会一直监测5G信号的强弱，符合某种情况就会切换到V2X，而V2X是开机就自启动的。


## 连接池
### 连接池和线程池的区别


### 为什么要使用连接池
因为MySQL和Redis的每次查询都需要进行连接、认证、MySQL和TCP的关闭，所以通过建立连接池来完成这些过程，从而复用一些连接。

### 连接池的设计
- 创建连接：需要配置的参数之类的`new Cacheconn`
- 需要创建一个池来管理连接
	- 请求获取连接，返回一个可用的连接`CacheConn* GetCacheConn()`
	- 归还连接给线程池`void RelCacheConn(CacheConn* pCacheConn)`
	- 销毁资源``
- 
















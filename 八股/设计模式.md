# 设计模式
## 设计模式的原则
### 单一职责原则（S）
每个类只应该有一个引起它变化的原因。
类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。

### 开闭原则（O）
一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展
如果需要对软件原有代码进行修改，可能会给旧代码引入错误，也有可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试
可以定义一个相对稳定的抽象基类

### 里氏替换原则（L）
子类可以扩展父类的功能，但不能改变原有父类的功能。有父类的地方都可以替换成子类且不会引起任何错误和异常，但是反之未必。  
覆盖或者实现父类方法时输入参数可以被放大：子类可以比父类多一些输入数据的类型，因为毕竟如果按照父类的方法调用时，还是可以执行父类的方法  
覆盖或实现父类方法时输出参数可以被缩小：子类输出的数据也一定是父类可以输出的。

### 迪米特法则（L）
一个类应该对自己需要耦合或调用的类知道得越少越好

### 接口隔离原则（I）
建立单一接口，接口尽量细化，接口中的方法尽量少。  

### 依赖倒置原则（D）
+ 高层模块不应该依赖于低层模块，二者都应该依赖于抽象：底层模块一般是容易变化的，而高层模块调用这些底层模块一般是不容易变化的，因此需要让高层模块调用底层模块所继承的抽象基类；
+ 抽象不应该依赖于实现细节
+ 实现细节应该依赖于抽象  

所谓的抽象就是接口或者抽象类，不能直接被实例化的；细节是实现类，可以被实例化。








## 单例模式
### 概述
目的：保证一个类只有一个实例（只能创建一个类对象），并且提供一个访问它的全局访问点（getInstance方法）
应用：
- 要求生成唯一序列号的场景
- 整个项目中需要一个共享访问点或共享数据，比如web页面的计时器
- 创建对象消耗的资源过多，比如访问IO和数据库等资源  

实现方式：将类成员声明为static类型的数据，并且隐藏类构造函数。根据创建对象的时机不同，可以分为以下两种类型：

### 饿汉式单例模式
在定义这个对象的时候就直接初始化了，因此是绝对线程安全的
```
// 通用版
class Singleton1 {
	Singleton1(){ }
	static Singleton1* _instance;
public:
	static Singleton1* GetSingleton() {
		return _instance;
	}
};
Singleton1* Singleton1::_instance = new Singleton1;
```

### 懒汉式单例模式
只有第一次使用这个对象的时候才会初始化，后续再次使用就不用再初始化了，这种方法是线程不安全的需要加锁。
```
// C++11前有锁
class Singleton2 {
	Singleton2(){
		pthread_mutex_init(&mutex);
	}
	static Singleton2* _instance;
	static pthread_mutex_t mutex;
public:
	static Singleton2* GetSingleton() {
		if (_instance == nullptr) {
			pthread_mutex_lock(&mutex);
			if (_instance == nullptr) {
				_instance = new Singleton1();	//但这里也不是很安全，因为会先分配内存再执行构造函数，如果分配过内存之后，其他线程获得了时间片，
												//就会导致得到一个无效的地址
			}
			pthread_mutex_unlock(&mutex);
		}
		return _instance;
	}
};
Singleton2::_instance = nullptr;

```

调用方法如下：
```
Singleton1* s1 = Singleton1::GetSingleton();
```
Meyers' singleton
```
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton inst;
        return inst;
    }
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
private:
    Singleton() { ... }
};
Singleton::getInstance();    //调用方法
```
这种方式只有初次调用的时候才会初始化，而且由于声明为static对象，因此不会被析构且不会重复创建相同的对象。C++11之后才能使用这种无锁的写法，因为C++11之后保证了static的线程安全，同样属于懒汉式。当然也可以使用call_once
https://blog.csdn.net/weixin_41519463/article/details/122244137

### 懒汉式和饿汉式的区别
总体上来说，懒汉式更好一些：
- 只有用时才会实例化，提高了内存利用率
- 因为不同文件执行的顺序是不确定的，所以如果其他文件中使用了该单例类，但是该单例类还没有初始化，就会出问题，而懒汉式只要调用就能实例化
- 如果有其他类继承了该单例类，那么这两个类就会共用同一个单例成员变量，不符合逻辑  

```
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton inst;
        return inst;
    }
    void on() {isOn = true;}
    void off() {isOn = false;}
    bool state() {return isOn;}
protected:
    bool isOn = true;
};
class Monitor: public Singleton {
public:
    static Monitor& getInstance() {
        static Monitor inst;
        return inst;
    }
    void addBrightness(int val) { brightness += val;}
    void subBrightness(int val) { brightness -= val;}
    int getBrightness() { return brightness;}

private:
    int brightness = 0;
};
int main() {
    Singleton::getInstance().on();
    Monitor::getInstance().on();
    cout<<"Singleton state:" << Singleton::getInstance().state()
        << " Monitor state:" << Monitor::getInstance().state()<<endl;

    Singleton::getInstance().off();
    cout<<"Singleton state:" << Singleton::getInstance().state()
        << " Monitor state:" << Monitor::getInstance().state()<<endl;
}
```
https://mp.weixin.qq.com/s/FZW7JYkxjpWnENmybeVh2g

## 工厂方法
### 目的
根据不同的需求创建不同类型的对象，每当新增一个需求，只需要新增一个工厂类和一个产品类即可，对原代码的改动小
### 具体实现
创建一个抽象的工厂和一个抽象的产品（都是抽象基类），抽象的工厂可以派生出不同的具体的工厂，抽象的产品可以派生出不同的具体的产品，对应的工厂生产对应的产品。抽象的工厂中定义了所有产品的共有的方法，调用时，只需要产生不同的工厂，就可以生产出不同的对象，必能对其进行操作。
### 优点
- 如果想创建一个对象，只需要给出条件
- 扩展性非常高
- 屏蔽了产品的具体实现过程，关注产品结构

### 缺点
如果每次增加一个新的产品，都需要增加一个实现类，就需要再重新构建一个新的工厂，类的个数增加了，增加了系统的复杂度

### 说人话
需要定义一个专门用来创建对象的接口，但是在这个接口中我们并不知道它需要实例化成哪一个类，这叫给其子类来决定。这适合在客户端代码不指明具体创建的类的对象时使用。
### 应用举例
比如有一个加密算法类，如果在代码中写死是哪一种加密算法，那么每当加密的时候就要调用这个加密算法类，但是这种方法的扩展性很差，如果希望支持另一种加密算法，那么就需要改掉整个程序中所有的原先的类。
因此我们可以使用工厂方法，定义一个抽象的工厂和一个抽象的类，在程序中调用加密算法类的时候，就调用这个抽象的加密算法类，这样在换用其他算法的时候，只需要修改一处即可：修改抽象工厂类的指针指向一个具体的工厂，由这个工厂再生产出一个具体的加密算法类，抽象的加密算法类指向这个具体的类即可。
即使可以不止一次地创建这个产品对象，也只需要初始化一次工厂对象。
```
class product {
public:
	virtual string Operation() const = 0;
};
class productA : public product {
public:
	string Operation() const override{
		return "productA\n";
	}
};
class productB : public product {
public:
	string Operation() const override {
		return "productB\n";
	}
};
class factory {
public:
	virtual product* FactoryMethod() const = 0;
	string SomeOperator() const {
		product* p = this->FactoryMethod();
		string result = p->Operation();
		delete p;
		return result;
	}
};
class factoryA : public factory{
public:
	product* FactoryMethod() const override {
		return new productA();
	}
};
class factoryB : public factory {
public:
	product* FactoryMethod() const override {
		return new productB();
	}
};
int main() {
	factory* f = new factoryA();
	prodeuct* p = f->FactoryMethod();
	cout << f->SomeOperator();
	delete f;
	delete p;
	f = new factoryB();
	p = f->FactoryMethod();
	cout << f->SomeOperator();
	delete f;
delete p;
}
```

## 抽象工厂

###具体实现
AbstractFactory是一个抽象工厂，为需要产品的对象提供接口来调用具体的工厂，创建的产品类型定义为AbstractProduct
ConcreteFactory是一个具体的工厂，创建具体的一类产品
AbstractProduct是一个抽象的产品，为工厂中生产的对象提供一个接口
ConcreteProduct是一个具体的产品，应该是一个三层结构
具体实现中，类内有一个成员的类型为AbstractFactory，同时提供一个接口设置类内的工厂类型
### 优点
当一个产品组中多个对象被设计在一起工作时，可以保证客户端只是用同一个产品组就可以得到具体的产品
### 缺点
非常难扩充，如果增加新的模块需要调整整个项目架构
### 说人话
生产出来的产品具有两个维度，需要根据其中一个维度创建一个抽象产品类，然后再根据另一维度创建一个具体类。而工厂中的具体的工厂就只能创建其中一种类，具体的接口（方法）可以根据需要创建不同的具体类。
### 应用实例
比如要管理两类数据表项，分别是用户和部门，又分别提供了MySQL和Access两种数据库进行操作，这样就对应了四类对象，因此需要使用抽象工厂，生产出来的第一类抽象产品是用户，又对应着SQL和access两类具体的产品；第二类抽象产品是部门，同样对应着SQL和access两类具体的产品；工厂又派生出两个具体的工厂，一个工厂生产SQL相关的产品，一个工厂生产access相关的产品。如果想换用另一种数据库，只需要换一下工厂类就行了。
```
//数据库表项：User
class User {
private:
	int id;
	string name;
public:
	int getID(){ return id; }
	string getName() { return name; }
	void setID(int ID) { this->id=ID; }
	void setName(string NAME) { this->name=NAME; }
};
//数据库表项：Department
class Department{
private:
	int id;
	string name;
public:
	int getID() { return id; }
	string getName() { return name; }
	void setID(int ID) { this->id=ID; }
	void setName(string NAME){this->name=NAME;}
};
//抽象产品A：IUser
class IUser{
public:
	virtual void Insert(User user)=0;
	virtual User* GetUser(int id)=0;
};
//详细产品A1：SqlserverUser
class SqlserverUser:public IUser
{
public:
	void Insert(User user){ cout<<"在SQL Server中给User表添加了一条记录"<<endl; }
	User* GetUser(int id){
		cout<<"在SQL Server中依据ID得到User表一条记录"<<endl;
		return NULL;
	}
};
//详细产品A2：AccessUser
class AccessUser:public IUser
{
public:
	void Insert(User user){cout<<"在Access中给User表添加了一条记录"<<endl;}
	User* GetUser(int id){
		cout<<"在Access中依据ID得到User表一条记录"<<endl;
		return NULL;
	}
};
//抽象产品B：IDepartment
class IDepartment
{
public:
	virtual void Insert(Department department)=0;
	virtual Department* GetDepartment(int id)=0;
};
//详细产品B1：SqlserverDepartment
class SqlserverDepartment:public IDepartment
{
public:
	void Insert(Department department){
		cout<<"在Sql Server中给Department表加入了一条记录"<<endl;
	}
	Department* GetDepartment(int id){
		cout<<"在SQL Server中依据ID得到Department表的一条记录"<<endl;
		return NULL;
	}
};
//详细产品B2：AccessDepartment
class AccessDepartment:public IDepartment
{
public:
	void Insert(Department department){cout<<"在Access中给Department表加入了一条记录"<<endl;}
	Department* GetDepartment(int id){
		cout<<"在Access中依据ID得到Department表的一条记录"<<endl;
		return NULL;
	}
};
//抽象工厂：IFactory
class IFactory
{
public:
	virtual IUser* CreateUser()=0;
	virtual IDepartment* CreateDepartment()=0;
};
//详细工厂1：SqlServerFactory
class SqlserverFactory:public IFactory
{
public:
	IUser* CreateUser(){return new SqlserverUser;}
	IDepartment* CreateDepartment(){return new SqlserverDepartment;}
};
//详细工厂2：AccessFactory
class AccessFactory:public IFactory
{
public:
	IUser* CreateUser(){return new AccessUser;}
	IDepartment* CreateDepartment(){return new AccessDepartment;}
};
//client
void  main()
{
	User user;
	Department department;
	//ConcreteFactory1
	IFactory* factory=new SqlserverFactory;	
	//ProductA1
	IUser* iu=factory->CreateUser();
	iu->Insert(user);
	iu->GetUser(1);
	//ProductB1
	IDepartment* id=factory->CreateDepartment();
	id->Insert(department);
	id->GetDepartment(1);
}
```
## 策略模式
### 具体实现
context封装角色：用于屏蔽高层模块对策略或算法的直接访问，里面包含一个抽象策略的指针，当需要某种策略的时候，直接更新这个指针就可以。
strategy抽象策略角色：是策略的抽象接口，定义了每个策略或算法的操作，是一个纯虚基类
concretestrategy具体策略角色：实现具体的算法。

```
#include<iostream>
#include<string>
#include<algorithm>
#include<vector>
using namespace std;
class strategy {
public:
	virtual string operation(const vector<string>& v) = 0;
};
class context {
	shared_ptr<strategy> mStrategy;
public:
	context(shared_ptr<strategy> strategy) : mStrategy(strategy) {}
	void setStrategy(shared_ptr<strategy> strategy) {
		mStrategy.reset();
		this->mStrategy = strategy;
	}
	void doSomething() const {
		cout << mStrategy.get()->operation({ "z","b","c" }) << endl;
	}
};
class strategyA : public strategy{
public:
	string operation(const vector<string>& v) {
		string res = "";
		for_each(v.begin(), v.end(), [&res](const string& s) {res += s; });
		return res;
	}
};
class strategyB : public strategy {
public:
	string operation(const vector<string>& v) {
		string res = "";
		for_each(v.begin(), v.end(), [&res](const string& s) {res += s; });
		sort(res.begin(), res.end());
		return res;
	}
};
int main() {
	auto sa = shared_ptr<strategy>(new strategyA());
	auto sb = shared_ptr<strategy>(new strategyB());
	auto ct = shared_ptr<context>(new context(sa));
	ct.get()->doSomething();
}
```

## 适配器模式
### 定义
两个彼此间没有太大关联的类，想进行交互完毕某些事情。假设直接去改动各自的接口，就显得有些繁琐了。能够加个中间类，用它来协调两类之间的关系，完成相关业务。
适配器分为类适配器和对象适配器。
### 类适配器
适配器和适配者是**继承**关系，即适配器需要从源接口和目标接口多继承而成。在适配器中完成相应的逻辑转换
### 对象适配器
适配器（Adapter） 是一个可以同时与客户端和服务交互的类：它在实现客户端接口的同时封装了服务对象。适配器接受客户端通过适配器接口发起的调用，并将其转换为适用于被封装服务对象的调用。客户端代码只需通过接口与适配器交互即可，无需与具体的适配器类耦合

## 状态模式
### 实现
- context上下文类：类内定义了各种具体状态类的指针，类内含有一个抽象状态类的指针，设置和获取当前状态的接口，以及具体的业务接口。其中具体的业务接口是交由state抽象状态类来定义的，并且由其具体的派生类来实现。
- state抽象状态类：是一个抽象基类，里面含有一个上下文类的指针，是上下文类通知状态改变的接口。并且定义了各种和状态相关的，且在context中定义过的对应的动作。
- concretestate具体状态类，实现具体的功能，在这个状态下可以实现的功能就直接实现，需要状态转移就通过context类的设置状态的接口进行转移，并且通过接口获取这个状态并执行。无法执行的动作就不执行。

### 具体过程
首先为context类new一个初始状态，也就是改变内含的状态类的状态，同时也会通知到状态类对象中改变状态。
当context类执行某些动作时，就会交由状态类来完成，由于context里面的状态类指针所指向的状态类是随时在变化的，所以处于不同状态时执行对应的动作也会由不同的结果。


## 观察者模式
### 实现
Subscriber抽象类：具体类的接口，定义了一系列的事件
Subscriber具体类：实现了抽象基类中的事件，可以注册或取消对发布者的观察
Publisher发布者类：内部维护一个抽象基类数组，每当有相应的事件发生时就遍历数组通知每个对象或者执行每个对象对应的操作，还应该提供注册和取消注册的接口


## 组合模式
### 实现
抽象基类：定义了每一个动作，并声明为虚函数
具体类：继承自抽象基类，实现每一个动作
容器类：继承自抽象基类，并且包含一个数组或map将这些具体类组合起来，实现的每一个动作都是调用的具体类的对应动作，容器类实际上只是执行一个遍历的动作

### 具体应用
比如PPT里面选中多个图形拖动或者放大，可以让这些图形都继承自同一个基类，然后选中这些图形时就创建一个容器类，把这些图形添加到这个容器类中，执行一些动作时，实际上执行的就是这个容器的动作，而容器中则遍历每一个元素再去执行对应的动作

## 建造者模式
### 定义
Director类：里面包含一个Builder类指针，可以通过改变这个指针具体所指向的类来改变建造的产品。
Builder类：里面含有一个产品类，并且定义了一系列的抽象动作
ConcreteBuilder类：继承自产品类，并且通过产品类中的动作来实现这些动作

对于一个复杂对象的创建工作，通常由各个部分的子对象用一定的算法构成，由于需求变化，这个对象的各个部分经常面临剧烈的变化，但是将其组合在一起的算法却相对稳定

## 装饰模式
### 结构
component组件类：抽象基类，定义了具体的操作方法
具体组件类：继承自组件类，实现了最基本的方法，可以为这个类加组件
装饰器基类：继承自抽象基类，里面包含一个组件类指针，重新定义了组件类中的方法，该方法内部调用这个组件类指针的方法
具体装饰器类：继承自装饰器基类，实现具体的装饰，需要执行组件类的方法，然后再执行自己加入的过程。


## 设计模式综合应用
### 平台返奖流程设计————工厂模式 + 策略模式
对于每个用户都会执行判断用户类型——发放奖励——更新奖励这样的流程，但是对于不同的用户有着不同的奖励发放策略，而这个策略可能会随着业务的调整而调整
因此可以使用工厂模式产生不同的策略，使用策略模式执行不同的策略
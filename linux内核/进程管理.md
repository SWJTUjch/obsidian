# 进程描述符task_struct
## task_struct的存储
- 由slab分配在栈底或栈顶，创建一个thread_info结构体，其中有一项task_struct类型的指针，指向真正的进程描述符。
- 有些硬件体系回拿出一个寄存器专门用来存储task_struct的指针，但是寄存器不富余的体系就再内核栈的尾端创建thread_info结构并计算偏移得到实际的地址。
## 主要参数和内容
==进程状态==
- 运行、可中断、不可中断、被其他进程跟踪、停止
- 可以使用srt_task_state(task,state)函数设置进程状态

==父进程和子进程==
- 有一个指针指向父进程，还有一个链表存储子进程

# 创建进程
==fork==
无论使用哪种函数创建进程，其实最终都是根据各自的参数调用clone()函数，然后clone调用do_fork()函数，do_fork调用copy_process函数，其功能如下：
- 为新进程创建一个内核栈、thread_info结构和task_struct，这些值都和父进程相同，文件描述符也和父进程相同
- 检查并确保创建该子进程之后，用户拥有的进程数不会超出资源的限制
- 将那些与父进程中不同的数据清零，主要是一些统计信息
- 子进程状态被设置为不可中断，避免被唤醒执行
- 更新task_struct的flags成员，表明进程是否有root用户权限的标志被清零，表明用户还没有调用exec的标志被设置
-  为新进程分配一个新的进程ID
- 根据传入参数的不同，还要拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。
-  Copy_process函数返回一个指向子进程的指针
-  新创建的子进程会被唤醒并运行

==vfork==
vfork不会复制父进程的页表项
子进程执行后，并不会立即调用父进程来执行，而是等待子进程给父进程通过vfork_done指针向它发送信号。调用mm_release时函数会用于进程退出内存地址空间，并且检查vfork_done是否为空，如果不为空，则向父进程发送信号，允许父进程来执行。这样，子进程就在自己的新的空间中运行，而父进程也恢复了在原地址空间中的运行。







